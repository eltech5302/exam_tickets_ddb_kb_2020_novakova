___
# Вопрос 13: Системные (встроенные) типы данных. Создание и удаление пользовательских типов данных.
___

**Тип данных** – это характеристика, определяющая, какого рода данные будут храниться в объекте. Например: целые числа, числовые данные с плавающей запятой, данные денежного типа, дата, время, текст, двоичные данные и так далее. В Microsoft SQL Server существует набор системных типов данных, который и определяет все доступные по умолчанию типы данных для использования. У разработчиков также существует возможность создавать псевдонимы типов данных основанные на системных типах, а также собственные пользовательские типы данных

## Точные числа

Наименование типа | Хранилище | Описание
--- | --- | ---
BIT | Если в таблице до 8 bit-столбцов 1 байт, если от 9 до 16, то 2 байта и так далее. | Может принимать значения 1, 0 или NULL. Часто используется как тип данных Boolean. Строковые значения TRUE и FALSE можно преобразовать в значения данного типа: TRUE преобразуется в 1, а FALSE в 0
TINYINT | 1 байт | Целые числа от 0 до 255
SMALLINT | 2 байта | от $$ -2^{15} $$ (-32 768) до $$ 2^{15} $$ - 1 (32 767)
INT | 4 байта | от $$ -2^{31} $$ (-2 147 483 648) до $$ 2^{31} $$ - 1 (2 147 483 647). Это основной целочисленный тип данных в Microsoft SQL Server
BIGINT | 8 байт | от $$ -2^{63} $$ (-9 223 372 036 854 775 808) до $$ 2^{63} $$ - 1 (9 223 372 036 854 775 807)
NUMERIC(P, S) и DECIMAL(P, S) | Точность: от 1 до 9 = 5 байт; от 10 до 19 = 9 байт; от 20 до 28 = 13 байт; от 29 до 38 = 17 байт. | Тип числовых данных с фиксированной точностью и масштабом. numeric и decimal функционально эквивалентны. P (точность) — максимальное количество десятичных разрядов числа, которые будут храниться (как слева, так и справа от десятичной запятой). Точность может быть значением в диапазоне от 1 до 38, по умолчанию 18. S (масштаб) — максимальное количество десятичных разрядов числа справа от десятичной запятой. Максимальное число цифр слева от десятичной запятой определяется как p — S (точность — масштаб). Масштаб может быть значение от 0 до P, по умолчанию 0. Максимальный размер хранилища зависит от точности. Тип данных NUMERIC и DECIMAL может принимать значение от $$ -10^{38} $$ + 1 до $$ 10^{38} $$ - 1.
SMALLMONEY | 4 байта | Тип данных для хранения денежных значений с точность до одной десятитысячной денежной единицы. Число от -214 748,3648 до 214 748,3647
MONEY | 8 байт | Тип данных для хранения денежных значений с точность до одной десятитысячной денежной единицы. Число от -922 337 203 685 477,5808 до 922 337 203 685 477,5807

## Приблизительные числа

Наименование типа | Хранилище | Описание
--- | --- | ---
FLOAT(N) | Зависит от значения n: От 1 до 24 (7 знаков) = 4 байта; От 25 до 53 (15 знаков) = 8 байт | Используется для числовых данных с плавающей запятой. N — это количество битов, используемых для хранения мантиссы числа в формате FLOAT при экспоненциальном представлении. n определяет точность данных и размер для хранения. Может принимать значение от 1 до 53, по умолчанию 53. Диапазон значений от $$ -1,79E+308 $$ до $$ 1,79E+308 $$
REAL | 4 байта | Используется для числовых данных с плавающей запятой. real соответствует в ISO типу FLOAT(24). Диапазон значений от $$ -3.40E+38 $$ до $$ 3.40E+38 $$

## Символьные строки

Наименование типа | Хранилище | Описание
--- | --- | ---
CHAR(N) | N байт | Строка с фиксированной длиной не в Юникоде, где N длина строки (от 1 до 8000). По умолчанию N = 1, если значение N не указано при использовании функций CAST и CONVERT, длина по умолчанию равна 30
VARCHAR(N/MAX) | Размер занимаемой памяти в байтах = количество введенных символов + 2 байта. Если указать MAX, то максимально возможный размер = $$ 2^{31} $$ - 1 байт (2 ГБ) | Строковые данные переменной длины не в Юникоде, где N длина строки (от 1 до 8000). По умолчанию N = 1, если значение N не указано при использовании функций CAST и CONVERT, длина по умолчанию равна 30
TEXT | Размер занимаемой памяти в байтах = количество введенных символов. Максимальный размер $$ 2^{31} $$ - 1 (2 147 483 647 байт, 2 ГБ) | Строка переменной длины не в Юникоде. Является устаревшим типом данных, рекомендуется использовать VARCHAR(MAX)

## Символьные строки в Юникоде

Наименование типа | Хранилище | Описание
--- | --- | ---
NCHAR(N) | n * 2 байт | Строка с фиксированной длиной в Юникоде, где N длина строки (от 1 до 4000). По умолчанию N = 1, если значение N не указано при использовании в функции CAST, длина по умолчанию равна 30
NVARCHAR(N/MAX) | Размер занимаемой памяти в байтах = количество введенных символов, умноженное на 2 + 2 байта. Если указать MAX, то максимально возможный размер = $$ 2^{31} $$ - 1 байт (2 ГБ) | Строка переменной длины в Юникоде, где n длина строки (от 1 до 4000). По умолчанию n = 1, если значение n не указано при использовании в функции CAST, длина по умолчанию равна 30
NTEXT | Размер занимаемой памяти в байтах = количество введенных символов, умноженное на 2. Максимальный размер $$ 2^{30} $$ - 1 (1 073 741 823 байт, 1 ГБ) | Строка переменной длины в Юникоде. Является устаревшим типом данных, рекомендуется использовать NVARCHAR(MAX)

## Дата и время

Наименование типа | Хранилище | Диапазон | Точность | Описание
--- | --- | --- | --- | ---
DATE | 3 байта | От 01.01.0001 до 31.12.9999 | 1 день | Используется для хранения даты
DATETIME | 8 байт | От 01.01.1753 00:00:00 до 31.12.9999 23:59:59,997 | 0,00333 секунды | Используется для хранения даты, включая время с точностью до одной трехсотой секунды
DATETIME2 | От 6 до 8 байт (в зависимости от точности: менее 3 цифр = 6 байт, 3-4 цифры = 7 байт, более 4 цифр = 8 байт) | От 01.01.0001 00:00:00.0000000 до 31.12.9999 23:59:59.9999999 | 100 наносекунд | Расширенный вариант типа данных datetime, имеет более широкий диапазон дат и большую точность в долях секунды (до 7 цифр)
SMALLDATETIME | 4 байта | От 01.01.1900 00:00:00 до 06.06.2079 23:59:00 |  1 минута | Сокращенный вариант типа данных datetime, имеет меньший диапазон дат и не имеет долей секунд
TIME(P) | От 3 до 5 байт | От 00:00:00.0000000 до 23:59:59.9999999 | 100 наносекунд | Используется для хранения времени дня. Точность может быть целым числом от 0 до 7, по умолчанию 7 (100 наносекунд, 5 байт). Если указать 0, то точность будет до секунды (3 байта)
DATETIMEOFFSET(P) | От 8 до 10 байт | От 01.01.0001 00:00:00.0000000 до 9999-12-31 23:59:59.9999999 | 100 наносекунд | Используется для хранения даты и времени, включая смещение часовой зоны относительно универсального глобального времени. Точность определяет количество знаков в дробной части секунды, данное значение может быть от 0 до 7, по умолчанию 7 (100 наносекунд, 10 байт)

## Двоичные данные

Наименование типа | Хранилище | Описание
--- | --- | ---
BINARY(N) | N байт | Двоичные данные фиксированной длины. N — значение от 1 до 8000. Если не указывать N, то значение по умолчанию 1, если не указать в функции CAST, то 30. Данный тип лучше использовать в случаях, когда размер данных, которые будут храниться в столбце, можно заранее определить
VARBINARY(N/MAX) | Размер занимаемой памяти в байтах = фактический размер данных + 2 байта. Если указать MAX, то максимально возможный размер = $$ 2^{31} $$ - 1 байт (2 ГБ) | Двоичные данные с переменной длиной. N — значение от 1 до 8000. Если не указывать N, то значение по умолчанию 1, если не указать в функции CAST, то 30. Данным типом лучше пользоваться, если размер данных в столбце заранее определить трудно. Если размер данных превышает 8000 байт, необходимо использовать тип VARBINARY(MAX)
IMAGE | Максимальный размер до $$ 2^{31} $$ - 1 (2 147 483 647 байт, 2 ГБ) | Двоичные данные с переменной длиной. Является устаревшим типом данных, рекомендуется использовать VARBINARY(MAX)

## Прочие типы данных

Наименование типа | Хранилище | Описание
--- | --- | ---
CURSOR | | Данный тип данных можно использовать в переменных или выходных параметрах хранимых процедур, которые содержат ссылку на курсор. Тип cursor не может быть использован в инструкции CREATE TABLE, т.е. для столбца в таблице. Может принимать значение NULL
TABLE | | Особый тип данных для переменных, который предназначен для хранения результирующего набора данных. Переменные с данным типом называют  табличные переменные
SQL_VARIANT | | Универсальный тип данных, который может хранить значения различных типов данных. Однако SQL_VARIANT может хранить значения не всех типов, которые есть в SQL сервере, например следующие типы нельзя сохранить при помощи типа данных SQL_VARIANT: VARCHAR(MAX), VARBINARY(MAX), NVARCHAR(MAX), XML, TEXT, NTEXT, IMAGE, ROWVERSION, HIERARCHYID, DATETIMEOFFSET, а также пространственные типы данных и определяемые пользователем типы. Тип SQL_VARIANT не может также иметь SQL_VARIANT в качестве базового типа
ROWVERSION(TIMESTAMP) | 8 байт | Тип данных ROWVERSION представляет собой автоматически создаваемые уникальные двоичные числа. В таблице может быть определен только один столбец типа ROWVERSION. После любого обновления строки или вставки новой строки в таблицу, которая содержит столбец типа ROWVERSION, значение увеличенной ROWVERSION вставляется в столбец с данным типом. Поэтому столбец с типом данных ROWVERSION не рекомендуется использовать в ключе, особенно в первичном ключе. TIMESTAMP является синонимом типа данных ROWVERSION, но данный синтаксис устарел и его использовать нежелательно
XML | Не более 2 ГБ | Используется для хранения XML-данных
UNIQUEIDENTIFIER | 16 байт | Глобальный уникальный идентификатор (GUID). Инициализировать столбец или переменную с типом uniqueidentifier можно с помощью функции NEWID или путем преобразования строки xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx, где каждый x – это шестнадцатеричная цифра (0–9 или A–F)
HIERARCHYID | Максимум 892 байта | Тип данных используется для представления положения в древовидной иерархии
Пространственные типы | | К пространственным типам относятся: geography – это географический пространственный тип данных, который используется для представления данных в системе координат круглой земли, GEOMETRY – это пространственный тип данных для представления данных в евклидовом пространстве (плоской системе координат)

## Пользовательские типы данных

Пользовательские типы данных определяемые средствами только Transact-SQL обязательно должны основываться на уже имеющихся базовых типах данных.
В качестве примера создадим пользовательский тип данных, который будет представлять собой шестизначный почтовый индекс.

```sql
    CREATE TYPE mType FROM nvarchar(6) NOT NULL;
```

Таким образом создания нового типа данных по сути не происходит. Вместо этого просто создаётся псевдоним для некоторого уже имеющегося типа.

Удаление происходит следующим образом.

```sql
    DROP TYPE mType;
```